# Дослідження сегментів пам'яті та архітектурних особливостей у FreeBSD

## Зміст
1. [Завдання 1: Визначення моменту переповнення `time_t`](#завдання-1-визначення-моменту-переповнення-time_t)  
2. [Завдання 2: Дослідження сегментів виконуваного файлу](#завдання-2-дослідження-сегментів-виконуваного-файлу)  
3. [Завдання 3: Визначення розташування стека та сегментів](#завдання-3-визначення-розташування-стека-та-сегментів)  
4. [Завдання 4: Дослідження стека процесу](#завдання-4-дослідження-стека-процесу)  
5. [Завдання 5: Можливість обійтися без лічильника команд (IP)](#завдання-5-можливість-обійтися-без-лічильника-команд-ip)  
6. [Завдання 6: Вимірювання часу доступу до різних сегментів пам'яті](#завдання-6-вимірювання-часу-доступу-до-різних-сегментів-памяті) 

---

## Завдання 1: Визначення моменту переповнення `time_t`

### Опис
Це завдання досліджує момент, коли відбудеться переповнення типу `time_t` на 32- та 64-бітних системах. Тип `time_t` використовується для представлення часу в секундах і є знаковим цілим числом. Його розмір (32 або 64 біти) залежить від архітектури системи, що впливає на дату переповнення.

### Команди для компіляції
- Для 32-бітної системи (вказуємо прапор `-m32` для примусової 32-бітної компіляції):
  ```bash
  gcc -m32 -Wall task1.c -o task1
  ```
- Для 64-бітної системи (вказуємо прапор `-m64`, хоча це стандартна поведінка):
  ```bash
  gcc -m64 -Wall task1.c -o task1
  ```

### Приклади виведення
- На 32-бітній системі:
  ```text
  Size of time_t: 4 bytes
  Maximum representable time: Tue Jan 19 05:14:07 2038
  ```
- На 64-бітній системі:
  ```text
  Size of time_t: 8 bytes
  Time conversion failed, value might be too large
  ```

### Аналіз сегментів виконуваного файлу для програми дослідження максимальних значень time_t
- 32-бітна компіляція
```
size task1
  text   data   bss    dec     hex   filename
  1330    288     8   1626   0x65a   task1
```
- 64-бітна компіляція
```
size task1
  text   data   bss    dec     hex   filename
  1512    576    16   2104   0x838   task1
```

| Сегмент | 32-бітна версія | 64-бітна версія | Різниця |
|---------|-----------------|-----------------|---------|
| text    | 1330 байт       | 1512 байт       | +182    |
| data    | 288 байт        | 576 байт        | +288    |
| bss     | 8 байт          | 16 байт         | +8      |
| Всього  | 1626 байт       | 2104 байт       | +478    |

### Сегмент text
- Призначення: містить інструкції (машинний код) програми.
- Причини різниці: в 64-бітній версії сегмент text більший на 182 байти через:
  - Використання 64-бітних інструкцій, які мають більший розмір опкодів
  - Оптимізацію та вирівнювання коду під 64-бітну архітектуру
  - Різні інструкції для роботи з 64-бітними регістрами та адресами

### Сегмент data
- Призначення: містить ініціалізовані глобальні та статичні змінні.
- Причини різниці: в 64-бітній версії сегмент data більший на 288 байт через:
  - Збільшені розміри внутрішніх структур даних стандартної бібліотеки
  - Збільшений розмір вказівників з 4 до 8 байт
  - Додаткове вирівнювання даних для 64-бітної архітектури

### Сегмент bss
- Призначення: містить неініціалізовані глобальні та статичні змінні.
- Причини різниці: в 64-бітній версії сегмент bss більший на 8 байт через:
  - Хоча в програмі явно не визначено неініціалізованих глобальних змінних, 
    компілятор і стандартна бібліотека використовують цей сегмент для власних потреб
  - Розмір адрес вказівників збільшився вдвічі (з 4 до 8 байт)
  - Різні вимоги до вирівнювання даних

### Висновки
- На 32-бітних системах переповнення time_t відбудеться 19 січня 2038 року через обмеження 32-бітного знакового числа (максимальне значення: 2,147,483,647 секунд від 1 січня 1970 року).
- На 64-бітних системах переповнення настане через мільярди років.
- Збільшення загального розміру: 64-бітна версія програми більша на 478 байт порівняно з 32-бітною версією.
- Найбільше зростання в сегменті data: відносне збільшення розміру сегменту data (на 100%) найбільше серед усіх сегментів, що пов'язано зі збільшенням розміру вказівників та внутрішніх структур даних.

## Завдання 2: Дослідження сегментів виконуваного файлу
